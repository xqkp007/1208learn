# V1.16 ä¸‰çº§åˆ†ç±»è§„åˆ™åŒ–æ²‰æ·€ä¸å®¡æ ¸è§¦å‘ - åˆ†é˜¶æ®µå¼€å‘è®¡åˆ’

---

## ç‰ˆæœ¬ä¿¡æ¯
- **ç‰ˆæœ¬å·**: V1.16
- **åˆ›å»ºæ—¥æœŸ**: 2026-01-26
- **å¯¹åº” PRD**: prd1.16.md

---

## ä¸€ã€æ€»ä½“æ¶æ„è®¾è®¡

### 1.1 æŠ€æœ¯é€‰å‹
- **åç«¯**: FastAPI + SQLAlchemy + APSchedulerï¼ˆå»¶ç»­ç°æœ‰æ¶æ„ï¼‰
- **å‰ç«¯**: React + TypeScriptï¼ˆæ— éœ€æ–°å¢é¡µé¢ï¼‰
- **ç‰ˆæœ¬å·**: v1.16

### 1.2 æ•°æ®æµè®¾è®¡
```
å·¥å•æ•°æ®(work_order) â†’ é˜ˆå€¼åˆ¤æ–­ â†’ æ ·æœ¬æŠ½å– â†’ AICOè§„åˆ™ç”Ÿæˆ â†’ å¾…å®¡æ ¸è¡¨ â†’ äººå·¥å®¡æ ¸
     â†“                    â†“           â†“              â†“              â†“
  å®šæ—¶ç»Ÿè®¡           æœˆåº¦æ‰¹å¤„ç†     è§„åˆ™ç”ŸæˆæœåŠ¡    å®¡æ ¸å·¥ä½œå°     å›ºåŒ–åˆ°æ­£å¼è¡¨
```

### 1.3 æ–°å¢ç›®å½•ç»“æ„
```
backend/
â”œâ”€â”€ app/
â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â””â”€â”€ v1_16/                      # æ–°å¢ v1.16 è·¯ç”±
â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â””â”€â”€ taxonomy_candidate_routes.py  # å€™é€‰åˆ†ç±»æ¥å£
â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â””â”€â”€ work_order.py               # æ–°å¢å·¥å•æ¨¡å‹ï¼ˆæˆ–å¤ç”¨ç°æœ‰ï¼‰
â”‚   â”œâ”€â”€ schemas/
â”‚   â”‚   â””â”€â”€ taxonomy_candidate.py       # æ–°å¢å€™é€‰åˆ†ç±» Schema
â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â””â”€â”€ taxonomy_candidate.py       # æ–°å¢å€™é€‰åˆ†ç±»æœåŠ¡
â”‚   â””â”€â”€ jobs/
â”‚       â””â”€â”€ scheduler.py                # æ‰©å±•ï¼šæ–°å¢å®šæ—¶ä»»åŠ¡
â”œâ”€â”€ sql/
â”‚   â””â”€â”€ kb_taxonomy_candidate_v1_16.sql # æ–°å¢è¡¨ç»“æ„è„šæœ¬ï¼ˆå¦‚éœ€ï¼‰
â””â”€â”€ main.py                             # ä¿®æ”¹ï¼šæ³¨å†Œ v1.16 è·¯ç”±
```

### 1.4 API æ¥å£è®¾è®¡
| è·¯ç”± | æ–¹æ³• | åŠŸèƒ½ |
|------|------|------|
| `/api/v1.16/candidates/stats` | GET | æŸ¥è¯¢å€™é€‰åˆ†ç±»ç»Ÿè®¡ï¼ˆæ‰‹åŠ¨è§¦å‘/è°ƒè¯•ï¼‰ |
| `/api/v1.16/candidates/trigger` | POST | æ‰‹åŠ¨è§¦å‘å€™é€‰ç”Ÿæˆæµç¨‹ |
| `/api/v1.16/admin/trigger-monthly-job` | POST | ç®¡ç†å‘˜æ‰‹åŠ¨è§¦å‘æœˆåº¦æ‰¹å¤„ç† |

---

## ğŸ¯ å¼€å‘å‰ç½®å‡†å¤‡

### å‰ç½®ä»»åŠ¡ï¼ˆå¿…é¡»å®Œæˆæ‰èƒ½å¼€å§‹é˜¶æ®µä¸€ï¼‰
- [ ] ç¡®è®¤ `work_order` è¡¨ç»“æ„åŠå­—æ®µå®šä¹‰
- [ ] ç¡®è®¤ `kb_taxonomy_nodes` è¡¨ç»“æ„ï¼ˆä¸‰çº§åˆ†ç±»æ­£å¼è¡¨ï¼‰
- [ ] ç¡®è®¤ `kb_taxonomy_review_items` å’Œ `kb_taxonomy_review_cases` è¡¨ç»“æ„
- [ ] è·å– AICO è§„åˆ™ç”Ÿæˆæ¥å£ API Key
- [ ] å‡†å¤‡æµ‹è¯•æ•°æ®ï¼ˆè‡³å°‘ 50+ æ¡åŒåçš„ä¸‰çº§åˆ†ç±»å·¥å•æ•°æ®ï¼‰

---

## ğŸ“¦ é˜¶æ®µä¸€ï¼šå€™é€‰ä¸‰çº§åˆ†ç±»è¯†åˆ«ä¸é˜ˆå€¼è§¦å‘
**å¯¹åº” PRD**: US-1.16.1

### å¼€å‘ç›®æ ‡
ä»å·¥å•ä¸­æå–ä¸‰çº§åˆ†ç±»ï¼Œè¿‡æ»¤å·²å­˜åœ¨çš„åˆ†ç±»ï¼Œç»Ÿè®¡æœˆåº¦å‡ºç°æ¬¡æ•°ï¼Œâ‰¥50 æ¬¡è§¦å‘å€™é€‰ç”Ÿæˆã€‚

---

### ä»»åŠ¡æ¸…å•

#### ä»»åŠ¡ 1.1: æ•°æ®æ¨¡å‹ä¸ Schema å®šä¹‰
**æ–‡ä»¶**:
- `backend/app/models/work_order.py` (æ–°å»º)
- `backend/app/schemas/taxonomy_candidate.py` (æ–°å»º)

**å¼€å‘å†…å®¹**:
```python
# models/work_order.py
class WorkOrder(Base):
    __tablename__ = 'work_order'
    id = Column(Integer, primary_key=True)
    group_code = Column(Integer)  # 1=æ°´åŠ¡, 2=å…¬äº¤
    nature = Column(String)         # ä¸šåŠ¡æ€§è´¨
    ticket_type = Column(Text)      # å…¬äº¤: JSONæ•°ç»„
    work_order_type_details = Column(String)  # æ°´åŠ¡: ä¸‰çº§åˆ†ç±»
    appeal_content = Column(Text)   # ç”³è¯‰å†…å®¹
    update_time = Column(DateTime)  # ç»Ÿè®¡æ—¶é—´å­—æ®µ
```

```python
# schemas/taxonomy_candidate.py
from pydantic import BaseModel
from typing import Optional

class CandidateInfo(BaseModel):
    scope_code: str      # water/bus/bike
    l1_name: Optional[str]  # ä¸€çº§åˆ†ç±»åç§°
    l2_name: str         # äºŒçº§åˆ†ç±»åç§°
    l3_name: str         # ä¸‰çº§åˆ†ç±»åç§°
    count: int           # å‡ºç°æ¬¡æ•°
    month: str           # ç»Ÿè®¡æœˆä»½ (YYYY-MM)
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] Pydantic æ¨¡å‹å­—æ®µå®Œæ•´ï¼Œç±»å‹æ­£ç¡®
- [ ] SQLAlchemy æ¨¡å‹èƒ½æˆåŠŸåˆ›å»º

---

#### ä»»åŠ¡ 1.2: åˆ†ç±»è§£æé€»è¾‘
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py` (æ–°å»º)

**å¼€å‘å†…å®¹**:
```python
from typing import Optional
import json
from dataclasses import dataclass

@dataclass
class CategoryInfo:
    l1: Optional[str]
    l2: str
    l3: str
    scope_code: str  # water/bus/bike

def parse_work_order_category(order: WorkOrder) -> Optional[CategoryInfo]:
    """è§£æå·¥å•çš„åˆ†ç±»å±‚çº§"""
    if order.group_code == 1:  # æ°´åŠ¡
        return CategoryInfo(
            l1=order.nature,
            l2=order.ticket_type,
            l3=order.work_order_type_details,
            scope_code='water'
        )
    elif order.group_code == 2:  # å…¬äº¤
        try:
            ticket_types = json.loads(order.ticket_type)
            if order.nature == 'è‡ªè¡Œè½¦' and len(ticket_types) == 2:
                return CategoryInfo(l1=None, l2=ticket_types[0], l3=ticket_types[1], scope_code='bike')
            elif order.nature == 'å…¬äº¤' and len(ticket_types) == 3:
                return CategoryInfo(l1=None, l2=ticket_types[0], l3=ticket_types[2], scope_code='bus')
        except (json.JSONDecodeError, IndexError):
            return None
    return None
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ°´åŠ¡å·¥å•è§£ææ­£ç¡®ï¼šä¸€çº§=natureï¼ŒäºŒçº§=ticket_typeï¼Œä¸‰çº§=work_order_type_details
- [ ] å…¬äº¤è‡ªè¡Œè½¦è§£ææ­£ç¡®ï¼šäºŒçº§=arr[0]ï¼Œä¸‰çº§=arr[1]ï¼Œscope_code=bike
- [ ] å…¬äº¤å…¬äº¤è§£ææ­£ç¡®ï¼šäºŒçº§=arr[0]ï¼Œä¸‰çº§=arr[2]ï¼Œscope_code=bus
- [ ] å¼‚å¸¸ ticket_type è¿”å› None

---

#### ä»»åŠ¡ 1.3: å­˜åœ¨æ€§æ¯”å¯¹
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
from sqlalchemy.orm import Session
from app.models.kb_taxonomy import KbTaxonomy

def exists_in_kb(db: Session, l3_name: str, scope_code: str) -> bool:
    """æ£€æŸ¥ä¸‰çº§åˆ†ç±»æ˜¯å¦å·²å­˜åœ¨äºæ­£å¼è¡¨"""
    if scope_code == 'bike':
        # bike: scope_code=bike ä¸” level=2
        return db.query(KbTaxonomy).filter(
            KbTaxonomy.scope_code == 'bike',
            KbTaxonomy.level == 2,
            KbTaxonomy.name == l3_name
        ).first() is not None
    else:
        # water/bus: scope_code=water/bus ä¸” level=3
        return db.query(KbTaxonomy).filter(
            KbTaxonomy.scope_code == scope_code,
            KbTaxonomy.level == 3,
            KbTaxonomy.name == l3_name
        ).first() is not None
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] water ä¸‰çº§åˆ†ç±»åŒ¹é…ï¼šscope_code=water, level=3, name=l3_name
- [ ] bus ä¸‰çº§åˆ†ç±»åŒ¹é…ï¼šscope_code=bus, level=3, name=l3_name
- [ ] bike ä¸‰çº§åˆ†ç±»åŒ¹é…ï¼šscope_code=bike, level=2, name=l3_name

---

#### ä»»åŠ¡ 1.4: æœˆåº¦ç»Ÿè®¡ä¸é˜ˆå€¼åˆ¤æ–­
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
from datetime import datetime
import calendar
from collections import defaultdict
from typing import List

def identify_candidates(db: Session, year: int, month: int, threshold: int = 50) -> List[CandidateInfo]:
    """è¯†åˆ«å€™é€‰ä¸‰çº§åˆ†ç±»"""
    # 1. æŒ‰è‡ªç„¶æœˆæ‰«æå·¥å•
    start_date = datetime(year, month, 1)
    end_date = datetime(year, month, calendar.monthrange(year, month)[1], 23, 59, 59)

    orders = db.query(WorkOrder).filter(
        WorkOrder.update_time >= start_date,
        WorkOrder.update_time <= end_date
    ).all()

    # 2. è§£æå¹¶ç»Ÿè®¡
    stats = defaultdict(int)
    for order in orders:
        category = parse_work_order_category(order)
        if category and not exists_in_kb(db, category.l3, category.scope_code):
            key = (category.scope_code, category.l1 or '', category.l2 or '', category.l3)
            stats[key] += 1

    # 3. è¿‡æ»¤é˜ˆå€¼
    candidates = []
    for (scope, l1, l2, l3), count in stats.items():
        if count >= threshold:
            candidates.append(CandidateInfo(
                scope_code=scope,
                l1_name=l1 or None,
                l2_name=l2,
                l3_name=l3,
                count=count,
                month=f"{year}-{month:02d}"
            ))

    return candidates
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ­£ç¡®æŒ‰è‡ªç„¶æœˆè¿‡æ»¤å·¥å•ï¼ˆåŸºäº update_timeï¼‰
- [ ] ç»Ÿè®¡åŒåä¸‰çº§åˆ†ç±»å‡ºç°æ¬¡æ•°
- [ ] ä»…è¿”å› count >= threshold çš„å€™é€‰
- [ ] å·²å­˜åœ¨çš„åˆ†ç±»ä¸è¿›å…¥ç»Ÿè®¡

---

#### ä»»åŠ¡ 1.5: è°ƒè¯•æ¥å£
**æ–‡ä»¶**: `backend/app/api/v1_16/taxonomy_candidate_routes.py` (æ–°å»º)

**å¼€å‘å†…å®¹**:
```python
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.core.db import get_db
from app.services.taxonomy_candidate import TaxonomyCandidateService

router = APIRouter()

@router.get("/candidates/stats")
async def get_candidates_stats(
    year: int,
    month: int,
    threshold: int = 50,
    db: Session = Depends(get_db)
):
    """æŸ¥è¯¢å€™é€‰åˆ†ç±»ç»Ÿè®¡ï¼ˆè°ƒè¯•ç”¨ï¼‰"""
    service = TaxonomyCandidateService(db)
    candidates = service.identify_candidates(year, month, threshold)
    return {"year": year, "month": month, "candidates": candidates}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ¥å£è¿”å›ç¬¦åˆæ ¼å¼çš„å€™é€‰åˆ—è¡¨
- [ ] æ”¯æŒè‡ªå®šä¹‰é˜ˆå€¼å‚æ•°
- [ ] è¿”å›å­—æ®µå®Œæ•´ï¼šscope_code, l1_name, l2_name, l3_name, count, month

---

### é˜¶æ®µä¸€éªŒæ”¶åœºæ™¯

| åœºæ™¯ | GIVEN | WHEN | THEN |
|------|-------|------|------|
| åœºæ™¯1: æ°´åŠ¡è§¦å‘ | æŸæ°´åŠ¡ä¸‰çº§åˆ†ç±»ä¸Šæœˆå‡ºç°â‰¥50æ¬¡ä¸”ä¸å­˜åœ¨ | æ‰¹å¤„ç†ç»Ÿè®¡ | è¯¥åˆ†ç±»è¿›å…¥å€™é€‰åˆ—è¡¨ |
| åœºæ™¯2: å·²å­˜åœ¨è¿‡æ»¤ | è¯¥ä¸‰çº§åˆ†ç±»åç§°å·²å­˜åœ¨äº kb_taxonomy_nodes | æ‰¹å¤„ç†ç»Ÿè®¡ | ç³»ç»Ÿä¸è§¦å‘è¯¥åˆ†ç±» |
| åœºæ™¯3: å…¬äº¤å¼‚å¸¸ | å…¬äº¤è®°å½• ticket_type é JSON æˆ–é•¿åº¦ä¸åŒ¹é… | è§£æåˆ†ç±» | è¯¥è®°å½•è¢«è·³è¿‡ |

---

### é˜¶æ®µä¸€å®Œæˆæ ‡å‡†
- [ ] åˆ†ç±»è§£æé€»è¾‘é€šè¿‡å•å…ƒæµ‹è¯•
- [ ] å­˜åœ¨æ€§æ¯”å¯¹é€»è¾‘é€šè¿‡å•å…ƒæµ‹è¯•
- [ ] æœˆåº¦ç»Ÿè®¡é€»è¾‘é€šè¿‡å•å…ƒæµ‹è¯•
- [ ] è°ƒè¯•æ¥å£å¯æ­£å¸¸è°ƒç”¨å¹¶è¿”å›æ­£ç¡®ç»“æœ

---

## ğŸ¯ é˜¶æ®µäºŒï¼šè§„åˆ™ç”Ÿæˆä¸å€™é€‰å…¥åº“
**å¯¹åº” PRD**: US-1.16.2

### å¼€å‘ç›®æ ‡
å¯¹è§¦å‘çš„å€™é€‰åˆ†ç±»ï¼ŒæŠ½æ · 20 æ¡æ ·æœ¬ï¼Œè°ƒç”¨ AICO ç”Ÿæˆè§„åˆ™ï¼Œå†™å…¥å¾…å®¡æ ¸è¡¨ã€‚

---

### ä»»åŠ¡æ¸…å•

#### ä»»åŠ¡ 2.1: æ ·æœ¬æŠ½æ ·
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
import random
from datetime import datetime, timedelta

def sample_cases(db: Session, l3_name: str, scope_code: str, year: int, month: int, sample_size: int = 20) -> List[str]:
    """æŠ½æ ·å€™é€‰åˆ†ç±»çš„å·¥å•æ ·æœ¬"""
    start_date = datetime(year, month, 1)
    end_date = datetime(year, month, calendar.monthrange(year, month)[1], 23, 59, 59)

    # æŸ¥è¯¢åŒ¹é…çš„å·¥å•
    query = db.query(WorkOrder.appeal_content).filter(
        WorkOrder.update_time >= start_date,
        WorkOrder.update_time <= end_date
    )

    # æ ¹æ®ä¸åŒ scope_code ç­›é€‰
    if scope_code == 'water':
        query = query.filter(
            WorkOrder.group_code == 1,
            WorkOrder.work_order_type_details == l3_name
        )
    elif scope_code == 'bus':
        query = query.filter(
            WorkOrder.group_code == 2,
            WorkOrder.nature == 'å…¬äº¤',
            WorkOrder.ticket_type.like(f'%"{l3_name}"%')
        )
    elif scope_code == 'bike':
        query = query.filter(
            WorkOrder.group_code == 2,
            WorkOrder.nature == 'è‡ªè¡Œè½¦',
            WorkOrder.ticket_type.like(f'%"{l3_name}"%')
        )

    orders = query.all()
    contents = [o.appeal_content for o in orders if o.appeal_content]

    # éšæœºæŠ½æ ·
    if len(contents) <= sample_size:
        return contents
    return random.sample(contents, sample_size)
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ ¹æ®åˆ†ç±»åç§°å’Œ scope_code æ­£ç¡®ç­›é€‰å·¥å•
- [ ] ä¸è¶³ 20 æ¡æ—¶è¿”å›å…¨é‡
- [ ] è¶³è¿‡ 20 æ¡æ—¶éšæœºæŠ½æ ·

---

#### ä»»åŠ¡ 2.2: AICO è§„åˆ™ç”Ÿæˆæ¥å£è°ƒç”¨
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
import httpx
import logging
from app.core.settings import settings

logger = logging.getLogger(__name__)

async def call_aico_rule_generation(prompt: str) -> str:
    """è°ƒç”¨ AICO è§„åˆ™ç”Ÿæˆæ¥å£"""
    url = settings.AICO_RULE_GENERATION_URL
    api_key = settings.AICO_RULE_GENERATION_API_KEY

    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {api_key}"
    }

    payload = {
        "query": prompt,
        "stream": False
    }

    try:
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(url, json=payload, headers=headers)
            response.raise_for_status()
            data = response.json()
            return data["data"]["text"][0]
    except httpx.HTTPError as e:
        logger.error(f"AICO æ¥å£è°ƒç”¨å¤±è´¥: {e}")
        raise
    except (KeyError, IndexError) as e:
        logger.error(f"AICO å“åº”æ ¼å¼è§£æå¤±è´¥: {e}")
        raise ValueError("AICO å“åº”æ ¼å¼ä¸æ­£ç¡®")
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ­£ç¡®è°ƒç”¨ AICO æ¥å£
- [ ] æ­£ç¡®è§£æè¿”å›çš„ `data.text[0]` å­—æ®µ
- [ ] å¼‚å¸¸æ—¶æœ‰é”™è¯¯å¤„ç†å’Œæ—¥å¿—

---

#### ä»»åŠ¡ 2.3: è§„åˆ™ç”Ÿæˆä¸å…¥åº“é€»è¾‘
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
from app.models.kb_taxonomy_review import KbTaxonomyReviewItem, KbTaxonomyReviewCase

def build_rule_prompt(l1_name: Optional[str], l2_name: str, l3_name: str, samples: List[str]) -> str:
    """ç»„è£…è§„åˆ™ç”Ÿæˆæç¤ºè¯"""
    l1_part = f"ä¸€çº§åˆ†ç±»: {l1_name}\n" if l1_name else ""
    samples_part = "\n".join([f"{i+1}. {s}" for i, s in enumerate(samples)])

    prompt = f"""
è¯·æ ¹æ®ä»¥ä¸‹ä¿¡æ¯ç”Ÿæˆä¸‰çº§åˆ†ç±»"{l3_name}"çš„å®šä¹‰è§„åˆ™ï¼š

{l1_part}äºŒçº§åˆ†ç±»: {l2_name}
ä¸‰çº§åˆ†ç±»: {l3_name}

å‚è€ƒæ¡ˆä¾‹:
{samples_part}

è¯·ç®€æ´æè¿°è¯¥ä¸‰çº§åˆ†ç±»çš„ç‰¹å¾è§„åˆ™ï¼Œè¦æ±‚ï¼š
1. å‡†ç¡®åæ˜ è¯¥åˆ†ç±»çš„æ ¸å¿ƒç‰¹å¾
2. è¯­è¨€ç®€æ´æ˜ç¡®
3. é¿å…ä¸å…¶ä»–åˆ†ç±»æ··æ·†
"""
    return prompt

async def generate_rules_and_save(db: Session, candidate: CandidateInfo) -> KbTaxonomyReviewItem:
    """ç”Ÿæˆè§„åˆ™å¹¶å†™å…¥å®¡æ ¸è¡¨"""

    # 1. æ£€æŸ¥é‡å¤
    existing = db.query(KbTaxonomyReviewItem).filter(
        KbTaxonomyReviewItem.scope_code == candidate.scope_code,
        KbTaxonomyReviewItem.l3_name == candidate.l3_name,
        KbTaxonomyReviewItem.status.in_(['pending', 'accepted'])
    ).first()

    if existing:
        raise ValueError(f"å·²å­˜åœ¨å¾…å®¡æ ¸/å·²é€šè¿‡çš„å®¡æ ¸é¡¹: {candidate.l3_name}")

    # 2. æŠ½æ ·
    year, month = map(int, candidate.month.split('-'))
    samples = sample_cases(db, candidate.l3_name, candidate.scope_code, year, month)

    if not samples:
        raise ValueError(f"æœªæ‰¾åˆ°å·¥å•æ ·æœ¬: {candidate.l3_name}")

    # 3. ç»„è£…æç¤ºè¯
    prompt = build_rule_prompt(candidate.l1_name, candidate.l2_name, candidate.l3_name, samples)

    # 4. è°ƒç”¨ AICO ç”Ÿæˆè§„åˆ™
    rule_text = await call_aico_rule_generation(prompt)

    # 5. å†™å…¥å®¡æ ¸é¡¹
    review_item = KbTaxonomyReviewItem(
        scope_code=candidate.scope_code,
        l1_name=candidate.l1_name,
        l2_name=candidate.l2_name,
        l3_name=candidate.l3_name,
        definition=rule_text,
        status='pending'
    )
    db.add(review_item)
    db.flush()  # è·å– ID

    # 6. å†™å…¥æ¡ˆä¾‹
    for content in samples:
        case = KbTaxonomyReviewCase(
            review_item_id=review_item.id,
            content=content
        )
        db.add(case)

    db.commit()
    logger.info(f"æˆåŠŸç”Ÿæˆå®¡æ ¸é¡¹: {candidate.l3_name}, æ ·æœ¬æ•°: {len(samples)}")
    return review_item
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] é‡å¤æ£€æŸ¥æ­£ç¡®ï¼šè·³è¿‡ pending/accepted çŠ¶æ€çš„å®¡æ ¸é¡¹
- [ ] è§„åˆ™æ–‡æœ¬æ­£ç¡®å†™å…¥ definition å­—æ®µ
- [ ] æ¡ˆä¾‹æ­£ç¡®å…³è”åˆ° review_item_id
- [ ] äº‹åŠ¡æ­£ç¡®æäº¤æˆ–å›æ»š

---

#### ä»»åŠ¡ 2.4: æœˆåº¦æ‰¹å¤„ç†å‡½æ•°
**æ–‡ä»¶**: `backend/app/services/taxonomy_candidate.py`

**å¼€å‘å†…å®¹**:
```python
from datetime import timedelta

async def run_monthly_candidate_job(db: Session):
    """æœˆåº¦æ‰¹å¤„ç†ï¼šç»Ÿè®¡ â†’ ç”Ÿæˆè§„åˆ™ â†’ å…¥åº“"""
    now = datetime.now()
    if now.day != 1:
        logger.info("éæ¯æœˆ1å·ï¼Œè·³è¿‡æ‰¹å¤„ç†")
        return

    # ç»Ÿè®¡ä¸Šæœˆæ•°æ®
    last_month = now.replace(day=1) - timedelta(days=1)
    candidates = identify_candidates(db, last_month.year, last_month.month, threshold=50)

    logger.info(f"ä¸Šæœˆå€™é€‰åˆ†ç±»æ•°é‡: {len(candidates)}")

    # ç”Ÿæˆè§„åˆ™å¹¶å…¥åº“
    success_count = 0
    skip_count = 0
    fail_count = 0

    for candidate in candidates:
        try:
            await generate_rules_and_save(db, candidate)
            success_count += 1
            logger.info(f"æˆåŠŸç”Ÿæˆå®¡æ ¸é¡¹: {candidate.l3_name}")
        except ValueError as e:
            skip_count += 1
            logger.warning(f"è·³è¿‡é‡å¤é¡¹: {e}")
        except Exception as e:
            fail_count += 1
            logger.error(f"ç”Ÿæˆè§„åˆ™å¤±è´¥: {candidate.l3_name}, é”™è¯¯: {e}")

    logger.info(f"æœˆåº¦æ‰¹å¤„ç†å®Œæˆ: æˆåŠŸ{success_count}, è·³è¿‡{skip_count}, å¤±è´¥{fail_count}")
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] è‡ªåŠ¨åˆ¤æ–­æ˜¯å¦ä¸ºæ¯æœˆ1å·
- [ ] æ­£ç¡®ç»Ÿè®¡ä¸Šæœˆæ•°æ®
- [ ] æ‰¹é‡å¤„ç†æ‰€æœ‰å€™é€‰åˆ†ç±»
- [ ] å®Œæ•´çš„æ—¥å¿—è®°å½•ï¼ˆæˆåŠŸ/è·³è¿‡/å¤±è´¥ï¼‰

---

#### ä»»åŠ¡ 2.5: å®šæ—¶ä»»åŠ¡æ³¨å†Œ
**æ–‡ä»¶**: `backend/app/jobs/scheduler.py` (ä¿®æ”¹)

**å¼€å‘å†…å®¹**:
```python
from apscheduler.schedulers.background import BackgroundScheduler

def register_v1_16_jobs(scheduler: BackgroundScheduler):
    """æ³¨å†Œ v1.16 å®šæ—¶ä»»åŠ¡"""
    from app.services.taxonomy_candidate import run_monthly_candidate_job_sync

    scheduler.add_job(
        run_monthly_candidate_job_sync,
        'cron',
        day='1',      # æ¯æœˆ1å·
        hour='2',     # å‡Œæ™¨2ç‚¹
        minute='0',
        id='monthly_taxonomy_candidate',
        replace_existing=True
    )
    logger.info("å·²æ³¨å†Œ v1.16 æœˆåº¦å€™é€‰åˆ†ç±»ç”Ÿæˆå®šæ—¶ä»»åŠ¡")
```

```python
# åœ¨ taxonomy_candidate.py ä¸­æ·»åŠ åŒæ­¥åŒ…è£…å‡½æ•°
def run_monthly_candidate_job_sync():
    """å®šæ—¶ä»»åŠ¡çš„åŒæ­¥åŒ…è£…å‡½æ•°"""
    from app.core.db import SessionLocal
    db = SessionLocal()
    try:
        import asyncio
        asyncio.run(run_monthly_candidate_job(db))
    finally:
        db.close()
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å®šæ—¶ä»»åŠ¡æ­£ç¡®æ³¨å†Œåˆ° scheduler
- [ ] æ‰§è¡Œæ—¶é—´ç¬¦åˆé¢„æœŸï¼šæ¯æœˆ1å·å‡Œæ™¨2ç‚¹
- [ ] ä»»åŠ¡å¯æ­£å¸¸æ‰§è¡Œ

---

#### ä»»åŠ¡ 2.6: æ‰‹åŠ¨è§¦å‘æ¥å£
**æ–‡ä»¶**: `backend/app/api/v1_16/taxonomy_candidate_routes.py`

**å¼€å‘å†…å®¹**:
```python
@router.post("/candidates/trigger")
async def trigger_candidate_generation(
    year: int,
    month: int,
    db: Session = Depends(get_db)
):
    """æ‰‹åŠ¨è§¦å‘å€™é€‰ç”Ÿæˆï¼ˆç®¡ç†å‘˜ç”¨ï¼‰"""
    candidates = identify_candidates(db, year, month, threshold=50)
    results = []

    for candidate in candidates:
        try:
            item = await generate_rules_and_save(db, candidate)
            results.append({
                "l3_name": candidate.l3_name,
                "status": "success",
                "review_item_id": item.id
            })
        except ValueError as e:
            results.append({
                "l3_name": candidate.l3_name,
                "status": "skipped",
                "reason": str(e)
            })
        except Exception as e:
            results.append({
                "l3_name": candidate.l3_name,
                "status": "failed",
                "reason": str(e)
            })

    return {
        "year": year,
        "month": month,
        "total": len(candidates),
        "success": sum(1 for r in results if r["status"] == "success"),
        "skipped": sum(1 for r in results if r["status"] == "skipped"),
        "failed": sum(1 for r in results if r["status"] == "failed"),
        "results": results
    }
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] æ¥å£æ”¯æŒæŒ‡å®šå¹´æœˆ
- [ ] è¿”å›æ¯ä¸ªå€™é€‰çš„å¤„ç†ç»“æœ
- [ ] å¼‚å¸¸æ—¶ä¸å½±å“å…¶ä»–å€™é€‰å¤„ç†
- [ ] è¿”å›ç»Ÿè®¡æ±‡æ€»ä¿¡æ¯

---

### é˜¶æ®µäºŒéªŒæ”¶åœºæ™¯

| åœºæ™¯ | GIVEN | WHEN | THEN |
|------|-------|------|------|
| åœºæ™¯1: å€™é€‰ç”ŸæˆæˆåŠŸ | æŸä¸‰çº§åˆ†ç±»è§¦å‘ä¸”æ— é‡å¤å®¡æ ¸é¡¹ | æ‰¹å¤„ç†è°ƒç”¨ | kb_taxonomy_review_items ç”Ÿæˆè®°å½•ï¼Œkb_taxonomy_review_cases å†™å…¥20æ¡ |
| åœºæ™¯2: é‡å¤å€™é€‰ | å·²å­˜åœ¨åŒ scope_code+l3_name çš„ pending/accepted | æ‰¹å¤„ç†å°è¯• | ç³»ç»Ÿè·³è¿‡è¯¥åˆ†ç±» |
| åœºæ™¯3: æ ·æœ¬ä¸è¶³ | ä¸Šæœˆæ ·æœ¬ä¸è¶³20æ¡ | ç³»ç»ŸæŠ½æ · | ä»…å†™å…¥ç°æœ‰å…¨éƒ¨æ ·æœ¬ |

---

### é˜¶æ®µäºŒå®Œæˆæ ‡å‡†
- [ ] æ ·æœ¬æŠ½æ ·é€»è¾‘é€šè¿‡å•å…ƒæµ‹è¯•
- [ ] AICO æ¥å£è°ƒç”¨æˆåŠŸï¼ˆmockæµ‹è¯•ï¼‰
- [ ] è§„åˆ™ç”Ÿæˆä¸å…¥åº“é€»è¾‘é€šè¿‡é›†æˆæµ‹è¯•
- [ ] å®šæ—¶ä»»åŠ¡æ­£ç¡®æ³¨å†Œ
- [ ] æ‰‹åŠ¨è§¦å‘æ¥å£å¯æ­£å¸¸è°ƒç”¨

---

## âœ… é˜¶æ®µä¸‰ï¼šäººå·¥å®¡æ ¸ä¸å›ºåŒ–
**å¯¹åº” PRD**: US-1.16.3

### å¼€å‘ç›®æ ‡
æ²¿ç”¨æ—¢æœ‰å®¡æ ¸æµç¨‹ï¼Œå®¡æ ¸å‘˜åœ¨ `/taxonomy-review` é¡µé¢å®¡æ ¸å€™é€‰è§„åˆ™ã€‚

---

### ä»»åŠ¡æ¸…å•

#### ä»»åŠ¡ 3.1: å‰ç«¯å®¡æ ¸é¡µé¢æ£€æŸ¥
**æ–‡ä»¶**: `frontend/src/pages/TaxonomyReviewWorkbenchPage.tsx` (æ£€æŸ¥)

**æ£€æŸ¥å†…å®¹**:
- [ ] é¡µé¢æ˜¯å¦æ”¯æŒæ˜¾ç¤º `definition` å­—æ®µï¼ˆè§„åˆ™æ–‡æœ¬ï¼‰
- [ ] é¡µé¢æ˜¯å¦æ”¯æŒæŸ¥çœ‹å…³è”æ¡ˆä¾‹ (`kb_taxonomy_review_cases`)
- [ ] å®¡æ ¸é€šè¿‡åçš„å›ºåŒ–é€»è¾‘æ˜¯å¦æ­£ç¡®
- [ ] å®¡æ ¸é©³å›é€»è¾‘æ˜¯å¦æ­£ç¡®

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç¡®è®¤é¡µé¢å¯æ˜¾ç¤ºè§„åˆ™æ–‡æœ¬
- [ ] ç¡®è®¤é¡µé¢å¯æ˜¾ç¤ºæ¡ˆä¾‹åˆ—è¡¨
- [ ] ç¡®è®¤å®¡æ ¸é€šè¿‡è°ƒç”¨æ­£ç¡®çš„ API
- [ ] ç¡®è®¤å®¡æ ¸é©³å›è°ƒç”¨æ­£ç¡®çš„ API

---

#### ä»»åŠ¡ 3.2: å®¡æ ¸é€šè¿‡æ¥å£ï¼ˆå¦‚éœ€æ–°å¢ï¼‰
**æ–‡ä»¶**: `backend/app/api/v1_14/kb_taxonomy_review_routes.py` (æ£€æŸ¥/ä¿®æ”¹)

**å¼€å‘å†…å®¹**:
```python
from fastapi import HTTPException
from app.models.kb_taxonomy import KbTaxonomy

@router.post("/review-items/{item_id}/approve")
async def approve_review_item(
    item_id: int,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """å®¡æ ¸é€šè¿‡ï¼šå›ºåŒ–åˆ°æ­£å¼è¡¨"""
    item = db.query(KbTaxonomyReviewItem).filter(
        KbTaxonomyReviewItem.id == item_id,
        KbTaxonomyReviewItem.status == 'pending'
    ).first()

    if not item:
        raise HTTPException(status_code=404, detail="å®¡æ ¸é¡¹ä¸å­˜åœ¨æˆ–å·²å¤„ç†")

    # 1. æŸ¥æ‰¾çˆ¶èŠ‚ç‚¹ ID
    parent_id = None
    if item.scope_code in ['water', 'bus']:
        # water/bus: éœ€è¦æ‰¾äºŒçº§åˆ†ç±»çš„èŠ‚ç‚¹
        parent_node = db.query(KbTaxonomy).filter(
            KbTaxonomy.scope_code == item.scope_code,
            KbTaxonomy.level == 2,
            KbTaxonomy.name == item.l2_name
        ).first()
        parent_id = parent_node.id if parent_node else None
    elif item.scope_code == 'bike':
        # bike: ä¸‰çº§åˆ†ç±»å®é™…ä¸Šæ˜¯ level=2ï¼Œå¯èƒ½éœ€è¦æ‰¾ä¸€çº§åˆ†ç±»
        if item.l1_name:
            parent_node = db.query(KbTaxonomy).filter(
                KbTaxonomy.scope_code == item.scope_code,
                KbTaxonomy.level == 1,
                KbTaxonomy.name == item.l1_name
            ).first()
            parent_id = parent_node.id if parent_node else None

    # 2. å›ºåŒ–åˆ°æ­£å¼åˆ†ç±»è¡¨
    level = 3 if item.scope_code in ['water', 'bus'] else 2
    taxonomy_node = KbTaxonomy(
        scope_code=item.scope_code,
        level=level,
        name=item.l3_name,
        parent_id=parent_id,
        definition=item.definition
    )
    db.add(taxonomy_node)

    # 3. åŒæ­¥æ¡ˆä¾‹ï¼ˆå¦‚éœ€è¦ï¼‰
    # æ ¹æ®ä¸šåŠ¡éœ€æ±‚å†³å®šæ˜¯å¦éœ€è¦åŒæ­¥æ¡ˆä¾‹åˆ°æ­£å¼è¡¨

    # 4. æ›´æ–°å®¡æ ¸çŠ¶æ€
    item.status = 'accepted'
    item.reviewed_by = current_user.username
    item.reviewed_at = datetime.now()

    db.commit()
    logger.info(f"å®¡æ ¸é€šè¿‡: {item.l3_name}, ç”± {current_user.username}")
    return {"message": "å®¡æ ¸é€šè¿‡", "review_item_id": item_id}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] ä¸‰çº§åˆ†ç±»æ­£ç¡®å›ºåŒ–åˆ° kb_taxonomy
- [ ] æ­£ç¡®è®¾ç½® levelï¼ˆwater/bus=3, bike=2ï¼‰
- [ ] æ­£ç¡®å…³è”çˆ¶èŠ‚ç‚¹ parent_id
- [ ] å®¡æ ¸çŠ¶æ€æ›´æ–°ä¸º accepted
- [ ] è®°å½•å®¡æ ¸äººå’Œå®¡æ ¸æ—¶é—´

---

#### ä»»åŠ¡ 3.3: å®¡æ ¸é©³å›æ¥å£ï¼ˆå¦‚éœ€æ–°å¢ï¼‰
**æ–‡ä»¶**: `backend/app/api/v1_14/kb_taxonomy_review_routes.py` (æ£€æŸ¥/ä¿®æ”¹)

**å¼€å‘å†…å®¹**:
```python
class RejectRequest(BaseModel):
    reason: str  # é©³å›åŸå› 

@router.post("/review-items/{item_id}/reject")
async def reject_review_item(
    item_id: int,
    request: RejectRequest,
    db: Session = Depends(get_db),
    current_user = Depends(get_current_user)
):
    """å®¡æ ¸é©³å›"""
    item = db.query(KbTaxonomyReviewItem).filter(
        KbTaxonomyReviewItem.id == item_id,
        KbTaxonomyReviewItem.status == 'pending'
    ).first()

    if not item:
        raise HTTPException(status_code=404, detail="å®¡æ ¸é¡¹ä¸å­˜åœ¨æˆ–å·²å¤„ç†")

    # ä»…æ›´æ–°çŠ¶æ€ï¼Œä¸å†™å…¥æ­£å¼åˆ†ç±»è¡¨
    item.status = 'discarded'
    item.reject_reason = request.reason
    item.reviewed_by = current_user.username
    item.reviewed_at = datetime.now()

    db.commit()
    logger.info(f"å®¡æ ¸é©³å›: {item.l3_name}, åŸå› : {request.reason}")
    return {"message": "å®¡æ ¸é©³å›", "review_item_id": item_id}
```

**éªŒæ”¶æ ‡å‡†**:
- [ ] å®¡æ ¸çŠ¶æ€æ›´æ–°ä¸º discarded
- [ ] ä¸å†™å…¥æ­£å¼åˆ†ç±»è¡¨
- [ ] è®°å½•é©³å›åŸå› 
- [ ] è®°å½•å®¡æ ¸äººå’Œå®¡æ ¸æ—¶é—´

---

#### ä»»åŠ¡ 3.4: æç¤ºè¯æ›´æ–°ï¼ˆäººå·¥æ“ä½œï¼‰
**è¯´æ˜**: PRD æ˜ç¡®æç¤ºè¯ç”±äººå·¥åœ¨æ—¢æœ‰é…ç½®ä½ç½®æ›´æ–°ï¼Œç³»ç»Ÿä¸è‡ªåŠ¨æ›´æ–°ã€‚

**éªŒæ”¶æ ‡å‡†**:
- [ ] ç¡®è®¤æç¤ºè¯é…ç½®ä½ç½®ï¼ˆå¦‚ AICO ä¸­çš„æç¤ºè¯é…ç½®æˆ–æ•°æ®åº“ä¸­çš„æç¤ºè¯è¡¨ï¼‰
- [ ] æä¾›æ“ä½œæ–‡æ¡£ï¼ˆå¦‚éœ€è¦ï¼‰

---

### é˜¶æ®µä¸‰éªŒæ”¶åœºæ™¯

| åœºæ™¯ | GIVEN | WHEN | THEN |
|------|-------|------|------|
| åœºæ™¯1: å®¡æ ¸é€šè¿‡ | ä¸€æ¡å¾…å®¡æ ¸ä¸‰çº§åˆ†ç±»è§„åˆ™ | å®¡æ ¸å‘˜ç‚¹å‡»é€šè¿‡ | åˆ†ç±»å›ºåŒ–åˆ°æ­£å¼è¡¨ï¼Œå®¡æ ¸é¡¹ä¸ºacceptedï¼Œæç¤ºè¯æŒ‰"ä¸‰çº§åˆ†ç±»åç§°"æ›´æ–° |
| åœºæ™¯2: å®¡æ ¸é©³å› | ä¸€æ¡å¾…å®¡æ ¸ä¸‰çº§åˆ†ç±»è§„åˆ™ | å®¡æ ¸å‘˜ç‚¹å‡»é©³å› | å®¡æ ¸é¡¹ä¸ºdiscardedï¼Œä¸å†™å…¥æ­£å¼è¡¨ |
| åœºæ™¯3: é‡å¤æ“ä½œ | å®¡æ ¸é¡¹å·²ä¸ºacceptedæˆ–discarded | å†æ¬¡å°è¯•æ“ä½œ | ç³»ç»Ÿæ‹’ç»è¯¥æ“ä½œ |

---

### é˜¶æ®µä¸‰å®Œæˆæ ‡å‡†
- [ ] å‰ç«¯å®¡æ ¸é¡µé¢åŠŸèƒ½å®Œæ•´
- [ ] å®¡æ ¸é€šè¿‡æ¥å£æµ‹è¯•é€šè¿‡
- [ ] å®¡æ ¸é©³å›æ¥å£æµ‹è¯•é€šè¿‡
- [ ] å®Œæ•´çš„å®¡æ ¸æµç¨‹ç«¯åˆ°ç«¯æµ‹è¯•é€šè¿‡

---

## ğŸ“‹ é˜¶æ®µé—´ä¾èµ–å…³ç³»

```
é˜¶æ®µä¸€ â†’ é˜¶æ®µäºŒ â†’ é˜¶æ®µä¸‰
  â†“        â†“        â†“
å€™é€‰è¯†åˆ« â†’ è§„åˆ™ç”Ÿæˆ â†’ äººå·¥å®¡æ ¸
```

- **é˜¶æ®µä¸€** å¿…é¡»å…ˆå®Œæˆï¼Œæä¾›å€™é€‰è¯†åˆ«èƒ½åŠ›
- **é˜¶æ®µäºŒ** ä¾èµ–é˜¶æ®µä¸€çš„å€™é€‰è¾“å‡º
- **é˜¶æ®µä¸‰** å¤ç”¨ç°æœ‰å®¡æ ¸æµç¨‹ï¼Œå¯èƒ½éœ€è¦å¾®è°ƒ

---

## ğŸ”§ ç¯å¢ƒå˜é‡é…ç½®

### æ–°å¢ç¯å¢ƒå˜é‡
```bash
# AICO è§„åˆ™ç”Ÿæˆæ¥å£é…ç½®
AICO_RULE_GENERATION_URL=http://20.17.39.132:11105/aicoapi/gateway/v2/chatbot/api_run/1768990846_34d4efbc-430d-485f-8aa1-67bf1e50028d
AICO_RULE_GENERATION_API_KEY=your_api_key_here

# å€™é€‰ç”Ÿæˆé…ç½®
TAXONOMY_CANDIDATE_THRESHOLD=50  # é»˜è®¤é˜ˆå€¼
TAXONOMY_SAMPLE_SIZE=20           # é»˜è®¤æŠ½æ ·æ•°é‡
TAXONOMY_MONTHLY_CRON=0 2 1 * *   # æ¯æœˆ1å·å‡Œæ™¨2ç‚¹
```

---

## ğŸ§ª æµ‹è¯•è®¡åˆ’

### å•å…ƒæµ‹è¯•
- [ ] `parse_work_order_category()` - åˆ†ç±»è§£æé€»è¾‘
- [ ] `exists_in_kb()` - å­˜åœ¨æ€§æ¯”å¯¹
- [ ] `identify_candidates()` - å€™é€‰è¯†åˆ«ä¸ç»Ÿè®¡
- [ ] `sample_cases()` - æ ·æœ¬æŠ½æ ·
- [ ] `build_rule_prompt()` - æç¤ºè¯ç»„è£…

### é›†æˆæµ‹è¯•
- [ ] å®Œæ•´çš„æœˆåº¦æ‰¹å¤„ç†æµç¨‹
- [ ] AICO æ¥å£è°ƒç”¨ï¼ˆå¯ä½¿ç”¨ mockï¼‰
- [ ] è§„åˆ™ç”Ÿæˆä¸å…¥åº“
- [ ] å®¡æ ¸é€šè¿‡æµç¨‹
- [ ] å®¡æ ¸é©³å›æµç¨‹

### ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] ä»å·¥å•æ•°æ®åˆ°å®¡æ ¸é€šè¿‡çš„å®Œæ•´æµç¨‹
- [ ] ä»å·¥å•æ•°æ®åˆ°å®¡æ ¸é©³å›çš„å®Œæ•´æµç¨‹
- [ ] é‡å¤å€™é€‰çš„æ­£ç¡®å¤„ç†
- [ ] å·²å­˜åœ¨åˆ†ç±»çš„æ­£ç¡®è¿‡æ»¤

---

## ğŸš€ ä¸Šçº¿è®¡åˆ’

### ä¸Šçº¿å‰ç½®æ£€æŸ¥
- [ ] æ‰€æœ‰å•å…ƒæµ‹è¯•é€šè¿‡
- [ ] æ‰€æœ‰é›†æˆæµ‹è¯•é€šè¿‡
- [ ] ä»£ç å®¡æŸ¥å®Œæˆ
- [ ] ç¯å¢ƒå˜é‡é…ç½®å®Œæˆ
- [ ] æ•°æ®åº“è¡¨ç»“æ„ç¡®è®¤æ— è¯¯

### ç°åº¦å‘å¸ƒè®¡åˆ’

#### 1. æµ‹è¯•ç¯å¢ƒéªŒè¯ (1-2å¤©)
- [ ] éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
- [ ] ä½¿ç”¨æµ‹è¯•æ•°æ®æ‰§è¡Œå®Œæ•´æµç¨‹
- [ ] ä¿®å¤å‘ç°çš„é—®é¢˜
- [ ] æ€§èƒ½æµ‹è¯•ï¼ˆå¤§æ•°æ®é‡åœºæ™¯ï¼‰

#### 2. é¢„ç”Ÿäº§ç¯å¢ƒéªŒè¯ (1å¤©)
- [ ] ä½¿ç”¨çœŸå®æ•°æ®å­é›†éªŒè¯
- [ ] éªŒè¯ä¸ç°æœ‰ç³»ç»Ÿçš„å…¼å®¹æ€§
- [ ] æ£€æŸ¥æ—¥å¿—è¾“å‡ºæ˜¯å¦å®Œæ•´

#### 3. ç”Ÿäº§ç¯å¢ƒä¸Šçº¿ (1å¤©)
- [ ] å®šæ—¶ä»»åŠ¡æ³¨å†Œ
- [ ] ç›‘æ§é¦–æ¬¡æœˆåº¦æ‰¹å¤„ç†æ‰§è¡Œ
- [ ] éªŒè¯å®¡æ ¸æµç¨‹
- [ ] å‡†å¤‡å›æ»šæ–¹æ¡ˆ

### å›æ»šæ–¹æ¡ˆ
- [ ] åœç”¨å®šæ—¶ä»»åŠ¡
- [ ] åˆ é™¤/ç¦ç”¨ v1.16 è·¯ç”±
- [ ] æ¸…ç†ç”Ÿæˆçš„å®¡æ ¸æ•°æ®ï¼ˆå¦‚éœ€è¦ï¼‰

---

## ğŸ“Š é£é™©ä¸åº”å¯¹

| é£é™© | å½±å“ | åº”å¯¹æªæ–½ |
|------|------|----------|
| `work_order` è¡¨ç»“æ„ä¸æ˜ç¡® | é˜»å¡å¼€å‘ | ç¬¬ä¸€æ—¶é—´ç¡®è®¤è¡¨ç»“æ„å’Œå­—æ®µæ˜ å°„ |
| AICO æ¥å£è°ƒç”¨å¤±è´¥ | è§„åˆ™ç”Ÿæˆå¤±è´¥ | å®ç°é‡è¯•æœºåˆ¶ + æ—¥å¿—è®°å½• |
| å·¥å•æ•°æ®é‡å·¨å¤§ | æ€§èƒ½é—®é¢˜ | åˆ†é¡µæŸ¥è¯¢ã€ç´¢å¼•ä¼˜åŒ– |
| æœˆåº¦æ‰¹å¤„ç†è€—æ—¶è¿‡é•¿ | å½±å“å®šæ—¶ä»»åŠ¡ | å®ç°å¹‚ç­‰æ€§ã€æ”¯æŒæ–­ç‚¹ç»­ä¼  |
| ä¸ v1.14 å®¡æ ¸è¡¨å†²çª | æ•°æ®æ··ä¹± | å…ˆæ£€æŸ¥ç°æœ‰è¡¨ç»“æ„ï¼Œç¡®è®¤å¤ç”¨æ–¹æ¡ˆ |
| å®šæ—¶ä»»åŠ¡æ‰§è¡Œæ—¶é—´é‡å  | èµ„æºç«äº‰ | åˆç†å®‰æ’ä¸åŒå®šæ—¶ä»»åŠ¡çš„æ‰§è¡Œæ—¶é—´ |

---

## ğŸ“ å¾…ç¡®è®¤äº‹é¡¹

1. **`work_order` è¡¨ç»“æ„** - å­—æ®µæ˜¯å¦å®Œæ•´ï¼Ÿæ˜¯å¦æœ‰ç´¢å¼•ï¼Ÿ
2. **å®¡æ ¸è¡¨æ˜¯å¦å¤ç”¨ v1.14** - è¿˜æ˜¯éœ€è¦æ–°å¢è¡¨ç»“æ„ï¼Ÿ
3. **å‰ç«¯å®¡æ ¸é¡µé¢** - æ˜¯å¦éœ€è¦è°ƒæ•´å­—æ®µæˆ–çŠ¶æ€ï¼Ÿ
4. **AICO API Key** - æ˜¯å¦æœ‰æ­£å¼ç¯å¢ƒçš„ Keyï¼Ÿ
5. **é˜ˆå€¼é…ç½®** - 50æ¬¡æ˜¯å¦å›ºå®šï¼Ÿéœ€è¦å¯é…ç½®å—ï¼Ÿ
6. **æ¡ˆä¾‹åŒæ­¥** - å®¡æ ¸é€šè¿‡åæ˜¯å¦éœ€è¦åŒæ­¥æ¡ˆä¾‹åˆ°æ­£å¼è¡¨ï¼Ÿ

---

## ğŸ“š å‚è€ƒèµ„æ–™

- PRD æ–‡æ¡£: `prd1.16.md`
- å‰ç«¯é¡¹ç›®åœ°å›¾: `frontend/PROJECT_MAP.md`
- åç«¯é¡¹ç›®åœ°å›¾: `backend/PROJECT_MAP.md`
- v1.14 åˆ†ç±»å®¡æ ¸æ¥å£: `backend/app/api/v1_14/kb_taxonomy_review_routes.py`
- v1.12 åˆ†ç±»çŸ¥è¯†åº“æ¥å£: `backend/app/api/v1_12/kb_taxonomy_routes.py`

---

## ğŸ“Œ æ›´æ–°è®°å½•

| æ—¥æœŸ | ç‰ˆæœ¬ | æ›´æ–°å†…å®¹ |
|------|------|----------|
| 2026-01-26 | v1.0 | åˆå§‹ç‰ˆæœ¬ï¼Œå®Œæˆåˆ†é˜¶æ®µå¼€å‘è®¡åˆ’ |
